/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: release-1.16
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.coding.apiserver.models;

import java.util.Objects;

import com.google.gson.annotations.SerializedName;
import com.coding.apiserver.custom.Quantity;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * PersistentVolumeSpec is the specification of a persistent volume.
 */
@ApiModel(description = "PersistentVolumeSpec is the specification of a persistent volume.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2020-04-29T07:27:12.312Z[Etc/UTC]")
public class VPersistentVolumeSpec {
  public static final String SERIALIZED_NAME_ACCESS_MODES = "accessModes";
  @SerializedName(SERIALIZED_NAME_ACCESS_MODES)
  private List<String> accessModes = null;

  public static final String SERIALIZED_NAME_AWS_ELASTIC_BLOCK_STORE = "awsElasticBlockStore";
  @SerializedName(SERIALIZED_NAME_AWS_ELASTIC_BLOCK_STORE)
  private VAWSElasticBlockStoreVolumeSource awsElasticBlockStore;

  public static final String SERIALIZED_NAME_AZURE_DISK = "azureDisk";
  @SerializedName(SERIALIZED_NAME_AZURE_DISK)
  private VAzureDiskVolumeSource azureDisk;

  public static final String SERIALIZED_NAME_AZURE_FILE = "azureFile";
  @SerializedName(SERIALIZED_NAME_AZURE_FILE)
  private VAzureFilePersistentVolumeSource azureFile;

  public static final String SERIALIZED_NAME_CAPACITY = "capacity";
  @SerializedName(SERIALIZED_NAME_CAPACITY)
  private Map<String, Quantity> capacity = null;

  public static final String SERIALIZED_NAME_CEPHFS = "cephfs";
  @SerializedName(SERIALIZED_NAME_CEPHFS)
  private VCephFSPersistentVolumeSource cephfs;

  public static final String SERIALIZED_NAME_CINDER = "cinder";
  @SerializedName(SERIALIZED_NAME_CINDER)
  private VCinderPersistentVolumeSource cinder;

  public static final String SERIALIZED_NAME_CLAIM_REF = "claimRef";
  @SerializedName(SERIALIZED_NAME_CLAIM_REF)
  private VObjectReference claimRef;

  public static final String SERIALIZED_NAME_CSI = "csi";
  @SerializedName(SERIALIZED_NAME_CSI)
  private VCSIPersistentVolumeSource csi;

  public static final String SERIALIZED_NAME_FC = "fc";
  @SerializedName(SERIALIZED_NAME_FC)
  private VFCVolumeSource fc;

  public static final String SERIALIZED_NAME_FLEX_VOLUME = "flexVolume";
  @SerializedName(SERIALIZED_NAME_FLEX_VOLUME)
  private VFlexPersistentVolumeSource flexVolume;

  public static final String SERIALIZED_NAME_FLOCKER = "flocker";
  @SerializedName(SERIALIZED_NAME_FLOCKER)
  private VFlockerVolumeSource flocker;

  public static final String SERIALIZED_NAME_GCE_PERSISTENT_DISK = "gcePersistentDisk";
  @SerializedName(SERIALIZED_NAME_GCE_PERSISTENT_DISK)
  private VGCEPersistentDiskVolumeSource gcePersistentDisk;

  public static final String SERIALIZED_NAME_GLUSTERFS = "glusterfs";
  @SerializedName(SERIALIZED_NAME_GLUSTERFS)
  private VGlusterfsPersistentVolumeSource glusterfs;

  public static final String SERIALIZED_NAME_HOST_PATH = "hostPath";
  @SerializedName(SERIALIZED_NAME_HOST_PATH)
  private VHostPathVolumeSource hostPath;

  public static final String SERIALIZED_NAME_ISCSI = "iscsi";
  @SerializedName(SERIALIZED_NAME_ISCSI)
  private VISCSIPersistentVolumeSource iscsi;

  public static final String SERIALIZED_NAME_LOCAL = "local";
  @SerializedName(SERIALIZED_NAME_LOCAL)
  private VLocalVolumeSource local;

  public static final String SERIALIZED_NAME_MOUNT_OPTIONS = "mountOptions";
  @SerializedName(SERIALIZED_NAME_MOUNT_OPTIONS)
  private List<String> mountOptions = null;

  public static final String SERIALIZED_NAME_NFS = "nfs";
  @SerializedName(SERIALIZED_NAME_NFS)
  private VNFSVolumeSource nfs;

  public static final String SERIALIZED_NAME_NODE_AFFINITY = "nodeAffinity";
  @SerializedName(SERIALIZED_NAME_NODE_AFFINITY)
  private VVolumeNodeAffinity nodeAffinity;

  public static final String SERIALIZED_NAME_PERSISTENT_VOLUME_RECLAIM_POLICY = "persistentVolumeReclaimPolicy";
  @SerializedName(SERIALIZED_NAME_PERSISTENT_VOLUME_RECLAIM_POLICY)
  private String persistentVolumeReclaimPolicy;

  public static final String SERIALIZED_NAME_PHOTON_PERSISTENT_DISK = "photonPersistentDisk";
  @SerializedName(SERIALIZED_NAME_PHOTON_PERSISTENT_DISK)
  private VPhotonPersistentDiskVolumeSource photonPersistentDisk;

  public static final String SERIALIZED_NAME_PORTWORX_VOLUME = "portworxVolume";
  @SerializedName(SERIALIZED_NAME_PORTWORX_VOLUME)
  private VPortworxVolumeSource portworxVolume;

  public static final String SERIALIZED_NAME_QUOBYTE = "quobyte";
  @SerializedName(SERIALIZED_NAME_QUOBYTE)
  private VQuobyteVolumeSource quobyte;

  public static final String SERIALIZED_NAME_RBD = "rbd";
  @SerializedName(SERIALIZED_NAME_RBD)
  private VRBDPersistentVolumeSource rbd;

  public static final String SERIALIZED_NAME_SCALE_I_O = "scaleIO";
  @SerializedName(SERIALIZED_NAME_SCALE_I_O)
  private VScaleIOPersistentVolumeSource scaleIO;

  public static final String SERIALIZED_NAME_STORAGE_CLASS_NAME = "storageClassName";
  @SerializedName(SERIALIZED_NAME_STORAGE_CLASS_NAME)
  private String storageClassName;

  public static final String SERIALIZED_NAME_STORAGEOS = "storageos";
  @SerializedName(SERIALIZED_NAME_STORAGEOS)
  private VStorageOSPersistentVolumeSource storageos;

  public static final String SERIALIZED_NAME_VOLUME_MODE = "volumeMode";
  @SerializedName(SERIALIZED_NAME_VOLUME_MODE)
  private String volumeMode;

  public static final String SERIALIZED_NAME_VSPHERE_VOLUME = "vsphereVolume";
  @SerializedName(SERIALIZED_NAME_VSPHERE_VOLUME)
  private VVsphereVirtualDiskVolumeSource vsphereVolume;


  public VPersistentVolumeSpec accessModes(List<String> accessModes) {

    this.accessModes = accessModes;
    return this;
  }

  public VPersistentVolumeSpec addAccessModesItem(String accessModesItem) {
    if (this.accessModes == null) {
      this.accessModes = new ArrayList<String>();
    }
    this.accessModes.add(accessModesItem);
    return this;
  }

   /**
   * AccessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
   * @return accessModes
  **/

  @ApiModelProperty(value = "AccessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes")

  public List<String> getAccessModes() {
    return accessModes;
  }


  public void setAccessModes(List<String> accessModes) {
    this.accessModes = accessModes;
  }


  public VPersistentVolumeSpec awsElasticBlockStore(VAWSElasticBlockStoreVolumeSource awsElasticBlockStore) {

    this.awsElasticBlockStore = awsElasticBlockStore;
    return this;
  }

   /**
   * Get awsElasticBlockStore
   * @return awsElasticBlockStore
  **/

  @ApiModelProperty(value = "")

  public VAWSElasticBlockStoreVolumeSource getAwsElasticBlockStore() {
    return awsElasticBlockStore;
  }


  public void setAwsElasticBlockStore(VAWSElasticBlockStoreVolumeSource awsElasticBlockStore) {
    this.awsElasticBlockStore = awsElasticBlockStore;
  }


  public VPersistentVolumeSpec azureDisk(VAzureDiskVolumeSource azureDisk) {

    this.azureDisk = azureDisk;
    return this;
  }

   /**
   * Get azureDisk
   * @return azureDisk
  **/

  @ApiModelProperty(value = "")

  public VAzureDiskVolumeSource getAzureDisk() {
    return azureDisk;
  }


  public void setAzureDisk(VAzureDiskVolumeSource azureDisk) {
    this.azureDisk = azureDisk;
  }


  public VPersistentVolumeSpec azureFile(VAzureFilePersistentVolumeSource azureFile) {

    this.azureFile = azureFile;
    return this;
  }

   /**
   * Get azureFile
   * @return azureFile
  **/

  @ApiModelProperty(value = "")

  public VAzureFilePersistentVolumeSource getAzureFile() {
    return azureFile;
  }


  public void setAzureFile(VAzureFilePersistentVolumeSource azureFile) {
    this.azureFile = azureFile;
  }


  public VPersistentVolumeSpec capacity(Map<String, Quantity> capacity) {

    this.capacity = capacity;
    return this;
  }

  public VPersistentVolumeSpec putCapacityItem(String key, Quantity capacityItem) {
    if (this.capacity == null) {
      this.capacity = new HashMap<String, Quantity>();
    }
    this.capacity.put(key, capacityItem);
    return this;
  }

   /**
   * A description of the persistent volume&#39;s resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
   * @return capacity
  **/

  @ApiModelProperty(value = "A description of the persistent volume's resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity")

  public Map<String, Quantity> getCapacity() {
    return capacity;
  }


  public void setCapacity(Map<String, Quantity> capacity) {
    this.capacity = capacity;
  }


  public VPersistentVolumeSpec cephfs(VCephFSPersistentVolumeSource cephfs) {

    this.cephfs = cephfs;
    return this;
  }

   /**
   * Get cephfs
   * @return cephfs
  **/

  @ApiModelProperty(value = "")

  public VCephFSPersistentVolumeSource getCephfs() {
    return cephfs;
  }


  public void setCephfs(VCephFSPersistentVolumeSource cephfs) {
    this.cephfs = cephfs;
  }


  public VPersistentVolumeSpec cinder(VCinderPersistentVolumeSource cinder) {

    this.cinder = cinder;
    return this;
  }

   /**
   * Get cinder
   * @return cinder
  **/

  @ApiModelProperty(value = "")

  public VCinderPersistentVolumeSource getCinder() {
    return cinder;
  }


  public void setCinder(VCinderPersistentVolumeSource cinder) {
    this.cinder = cinder;
  }


  public VPersistentVolumeSpec claimRef(VObjectReference claimRef) {

    this.claimRef = claimRef;
    return this;
  }

   /**
   * Get claimRef
   * @return claimRef
  **/

  @ApiModelProperty(value = "")

  public VObjectReference getClaimRef() {
    return claimRef;
  }


  public void setClaimRef(VObjectReference claimRef) {
    this.claimRef = claimRef;
  }


  public VPersistentVolumeSpec csi(VCSIPersistentVolumeSource csi) {

    this.csi = csi;
    return this;
  }

   /**
   * Get csi
   * @return csi
  **/

  @ApiModelProperty(value = "")

  public VCSIPersistentVolumeSource getCsi() {
    return csi;
  }


  public void setCsi(VCSIPersistentVolumeSource csi) {
    this.csi = csi;
  }


  public VPersistentVolumeSpec fc(VFCVolumeSource fc) {

    this.fc = fc;
    return this;
  }

   /**
   * Get fc
   * @return fc
  **/

  @ApiModelProperty(value = "")

  public VFCVolumeSource getFc() {
    return fc;
  }


  public void setFc(VFCVolumeSource fc) {
    this.fc = fc;
  }


  public VPersistentVolumeSpec flexVolume(VFlexPersistentVolumeSource flexVolume) {

    this.flexVolume = flexVolume;
    return this;
  }

   /**
   * Get flexVolume
   * @return flexVolume
  **/

  @ApiModelProperty(value = "")

  public VFlexPersistentVolumeSource getFlexVolume() {
    return flexVolume;
  }


  public void setFlexVolume(VFlexPersistentVolumeSource flexVolume) {
    this.flexVolume = flexVolume;
  }


  public VPersistentVolumeSpec flocker(VFlockerVolumeSource flocker) {

    this.flocker = flocker;
    return this;
  }

   /**
   * Get flocker
   * @return flocker
  **/

  @ApiModelProperty(value = "")

  public VFlockerVolumeSource getFlocker() {
    return flocker;
  }


  public void setFlocker(VFlockerVolumeSource flocker) {
    this.flocker = flocker;
  }


  public VPersistentVolumeSpec gcePersistentDisk(VGCEPersistentDiskVolumeSource gcePersistentDisk) {

    this.gcePersistentDisk = gcePersistentDisk;
    return this;
  }

   /**
   * Get gcePersistentDisk
   * @return gcePersistentDisk
  **/

  @ApiModelProperty(value = "")

  public VGCEPersistentDiskVolumeSource getGcePersistentDisk() {
    return gcePersistentDisk;
  }


  public void setGcePersistentDisk(VGCEPersistentDiskVolumeSource gcePersistentDisk) {
    this.gcePersistentDisk = gcePersistentDisk;
  }


  public VPersistentVolumeSpec glusterfs(VGlusterfsPersistentVolumeSource glusterfs) {

    this.glusterfs = glusterfs;
    return this;
  }

   /**
   * Get glusterfs
   * @return glusterfs
  **/

  @ApiModelProperty(value = "")

  public VGlusterfsPersistentVolumeSource getGlusterfs() {
    return glusterfs;
  }


  public void setGlusterfs(VGlusterfsPersistentVolumeSource glusterfs) {
    this.glusterfs = glusterfs;
  }


  public VPersistentVolumeSpec hostPath(VHostPathVolumeSource hostPath) {

    this.hostPath = hostPath;
    return this;
  }

   /**
   * Get hostPath
   * @return hostPath
  **/

  @ApiModelProperty(value = "")

  public VHostPathVolumeSource getHostPath() {
    return hostPath;
  }


  public void setHostPath(VHostPathVolumeSource hostPath) {
    this.hostPath = hostPath;
  }


  public VPersistentVolumeSpec iscsi(VISCSIPersistentVolumeSource iscsi) {

    this.iscsi = iscsi;
    return this;
  }

   /**
   * Get iscsi
   * @return iscsi
  **/

  @ApiModelProperty(value = "")

  public VISCSIPersistentVolumeSource getIscsi() {
    return iscsi;
  }


  public void setIscsi(VISCSIPersistentVolumeSource iscsi) {
    this.iscsi = iscsi;
  }


  public VPersistentVolumeSpec local(VLocalVolumeSource local) {

    this.local = local;
    return this;
  }

   /**
   * Get local
   * @return local
  **/

  @ApiModelProperty(value = "")

  public VLocalVolumeSource getLocal() {
    return local;
  }


  public void setLocal(VLocalVolumeSource local) {
    this.local = local;
  }


  public VPersistentVolumeSpec mountOptions(List<String> mountOptions) {

    this.mountOptions = mountOptions;
    return this;
  }

  public VPersistentVolumeSpec addMountOptionsItem(String mountOptionsItem) {
    if (this.mountOptions == null) {
      this.mountOptions = new ArrayList<String>();
    }
    this.mountOptions.add(mountOptionsItem);
    return this;
  }

   /**
   * A list of mount options, e.g. [\&quot;ro\&quot;, \&quot;soft\&quot;]. Not validated - mount will simply fail if one is invalid. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
   * @return mountOptions
  **/

  @ApiModelProperty(value = "A list of mount options, e.g. [\"ro\", \"soft\"]. Not validated - mount will simply fail if one is invalid. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options")

  public List<String> getMountOptions() {
    return mountOptions;
  }


  public void setMountOptions(List<String> mountOptions) {
    this.mountOptions = mountOptions;
  }


  public VPersistentVolumeSpec nfs(VNFSVolumeSource nfs) {

    this.nfs = nfs;
    return this;
  }

   /**
   * Get nfs
   * @return nfs
  **/

  @ApiModelProperty(value = "")

  public VNFSVolumeSource getNfs() {
    return nfs;
  }


  public void setNfs(VNFSVolumeSource nfs) {
    this.nfs = nfs;
  }


  public VPersistentVolumeSpec nodeAffinity(VVolumeNodeAffinity nodeAffinity) {

    this.nodeAffinity = nodeAffinity;
    return this;
  }

   /**
   * Get nodeAffinity
   * @return nodeAffinity
  **/

  @ApiModelProperty(value = "")

  public VVolumeNodeAffinity getNodeAffinity() {
    return nodeAffinity;
  }


  public void setNodeAffinity(VVolumeNodeAffinity nodeAffinity) {
    this.nodeAffinity = nodeAffinity;
  }


  public VPersistentVolumeSpec persistentVolumeReclaimPolicy(String persistentVolumeReclaimPolicy) {

    this.persistentVolumeReclaimPolicy = persistentVolumeReclaimPolicy;
    return this;
  }

   /**
   * What happens to a persistent volume when released from its claim. Valid options are Retain (default for manually created PersistentVolumes), Delete (default for dynamically provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the volume plugin underlying this PersistentVolume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
   * @return persistentVolumeReclaimPolicy
  **/

  @ApiModelProperty(value = "What happens to a persistent volume when released from its claim. Valid options are Retain (default for manually created PersistentVolumes), Delete (default for dynamically provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the volume plugin underlying this PersistentVolume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming")

  public String getPersistentVolumeReclaimPolicy() {
    return persistentVolumeReclaimPolicy;
  }


  public void setPersistentVolumeReclaimPolicy(String persistentVolumeReclaimPolicy) {
    this.persistentVolumeReclaimPolicy = persistentVolumeReclaimPolicy;
  }


  public VPersistentVolumeSpec photonPersistentDisk(VPhotonPersistentDiskVolumeSource photonPersistentDisk) {

    this.photonPersistentDisk = photonPersistentDisk;
    return this;
  }

   /**
   * Get photonPersistentDisk
   * @return photonPersistentDisk
  **/

  @ApiModelProperty(value = "")

  public VPhotonPersistentDiskVolumeSource getPhotonPersistentDisk() {
    return photonPersistentDisk;
  }


  public void setPhotonPersistentDisk(VPhotonPersistentDiskVolumeSource photonPersistentDisk) {
    this.photonPersistentDisk = photonPersistentDisk;
  }


  public VPersistentVolumeSpec portworxVolume(VPortworxVolumeSource portworxVolume) {

    this.portworxVolume = portworxVolume;
    return this;
  }

   /**
   * Get portworxVolume
   * @return portworxVolume
  **/

  @ApiModelProperty(value = "")

  public VPortworxVolumeSource getPortworxVolume() {
    return portworxVolume;
  }


  public void setPortworxVolume(VPortworxVolumeSource portworxVolume) {
    this.portworxVolume = portworxVolume;
  }


  public VPersistentVolumeSpec quobyte(VQuobyteVolumeSource quobyte) {

    this.quobyte = quobyte;
    return this;
  }

   /**
   * Get quobyte
   * @return quobyte
  **/

  @ApiModelProperty(value = "")

  public VQuobyteVolumeSource getQuobyte() {
    return quobyte;
  }


  public void setQuobyte(VQuobyteVolumeSource quobyte) {
    this.quobyte = quobyte;
  }


  public VPersistentVolumeSpec rbd(VRBDPersistentVolumeSource rbd) {

    this.rbd = rbd;
    return this;
  }

   /**
   * Get rbd
   * @return rbd
  **/

  @ApiModelProperty(value = "")

  public VRBDPersistentVolumeSource getRbd() {
    return rbd;
  }


  public void setRbd(VRBDPersistentVolumeSource rbd) {
    this.rbd = rbd;
  }


  public VPersistentVolumeSpec scaleIO(VScaleIOPersistentVolumeSource scaleIO) {

    this.scaleIO = scaleIO;
    return this;
  }

   /**
   * Get scaleIO
   * @return scaleIO
  **/

  @ApiModelProperty(value = "")

  public VScaleIOPersistentVolumeSource getScaleIO() {
    return scaleIO;
  }


  public void setScaleIO(VScaleIOPersistentVolumeSource scaleIO) {
    this.scaleIO = scaleIO;
  }


  public VPersistentVolumeSpec storageClassName(String storageClassName) {

    this.storageClassName = storageClassName;
    return this;
  }

   /**
   * Name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.
   * @return storageClassName
  **/

  @ApiModelProperty(value = "Name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.")

  public String getStorageClassName() {
    return storageClassName;
  }


  public void setStorageClassName(String storageClassName) {
    this.storageClassName = storageClassName;
  }


  public VPersistentVolumeSpec storageos(VStorageOSPersistentVolumeSource storageos) {

    this.storageos = storageos;
    return this;
  }

   /**
   * Get storageos
   * @return storageos
  **/

  @ApiModelProperty(value = "")

  public VStorageOSPersistentVolumeSource getStorageos() {
    return storageos;
  }


  public void setStorageos(VStorageOSPersistentVolumeSource storageos) {
    this.storageos = storageos;
  }


  public VPersistentVolumeSpec volumeMode(String volumeMode) {

    this.volumeMode = volumeMode;
    return this;
  }

   /**
   * volumeMode defines if a volume is intended to be used with a formatted filesystem or to remain in raw block state. Value of Filesystem is implied when not included in spec. This is a beta feature.
   * @return volumeMode
  **/

  @ApiModelProperty(value = "volumeMode defines if a volume is intended to be used with a formatted filesystem or to remain in raw block state. Value of Filesystem is implied when not included in spec. This is a beta feature.")

  public String getVolumeMode() {
    return volumeMode;
  }


  public void setVolumeMode(String volumeMode) {
    this.volumeMode = volumeMode;
  }


  public VPersistentVolumeSpec vsphereVolume(VVsphereVirtualDiskVolumeSource vsphereVolume) {

    this.vsphereVolume = vsphereVolume;
    return this;
  }

   /**
   * Get vsphereVolume
   * @return vsphereVolume
  **/

  @ApiModelProperty(value = "")

  public VVsphereVirtualDiskVolumeSource getVsphereVolume() {
    return vsphereVolume;
  }


  public void setVsphereVolume(VVsphereVirtualDiskVolumeSource vsphereVolume) {
    this.vsphereVolume = vsphereVolume;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VPersistentVolumeSpec v1PersistentVolumeSpec = (VPersistentVolumeSpec) o;
    return Objects.equals(this.accessModes, v1PersistentVolumeSpec.accessModes) &&
        Objects.equals(this.awsElasticBlockStore, v1PersistentVolumeSpec.awsElasticBlockStore) &&
        Objects.equals(this.azureDisk, v1PersistentVolumeSpec.azureDisk) &&
        Objects.equals(this.azureFile, v1PersistentVolumeSpec.azureFile) &&
        Objects.equals(this.capacity, v1PersistentVolumeSpec.capacity) &&
        Objects.equals(this.cephfs, v1PersistentVolumeSpec.cephfs) &&
        Objects.equals(this.cinder, v1PersistentVolumeSpec.cinder) &&
        Objects.equals(this.claimRef, v1PersistentVolumeSpec.claimRef) &&
        Objects.equals(this.csi, v1PersistentVolumeSpec.csi) &&
        Objects.equals(this.fc, v1PersistentVolumeSpec.fc) &&
        Objects.equals(this.flexVolume, v1PersistentVolumeSpec.flexVolume) &&
        Objects.equals(this.flocker, v1PersistentVolumeSpec.flocker) &&
        Objects.equals(this.gcePersistentDisk, v1PersistentVolumeSpec.gcePersistentDisk) &&
        Objects.equals(this.glusterfs, v1PersistentVolumeSpec.glusterfs) &&
        Objects.equals(this.hostPath, v1PersistentVolumeSpec.hostPath) &&
        Objects.equals(this.iscsi, v1PersistentVolumeSpec.iscsi) &&
        Objects.equals(this.local, v1PersistentVolumeSpec.local) &&
        Objects.equals(this.mountOptions, v1PersistentVolumeSpec.mountOptions) &&
        Objects.equals(this.nfs, v1PersistentVolumeSpec.nfs) &&
        Objects.equals(this.nodeAffinity, v1PersistentVolumeSpec.nodeAffinity) &&
        Objects.equals(this.persistentVolumeReclaimPolicy, v1PersistentVolumeSpec.persistentVolumeReclaimPolicy) &&
        Objects.equals(this.photonPersistentDisk, v1PersistentVolumeSpec.photonPersistentDisk) &&
        Objects.equals(this.portworxVolume, v1PersistentVolumeSpec.portworxVolume) &&
        Objects.equals(this.quobyte, v1PersistentVolumeSpec.quobyte) &&
        Objects.equals(this.rbd, v1PersistentVolumeSpec.rbd) &&
        Objects.equals(this.scaleIO, v1PersistentVolumeSpec.scaleIO) &&
        Objects.equals(this.storageClassName, v1PersistentVolumeSpec.storageClassName) &&
        Objects.equals(this.storageos, v1PersistentVolumeSpec.storageos) &&
        Objects.equals(this.volumeMode, v1PersistentVolumeSpec.volumeMode) &&
        Objects.equals(this.vsphereVolume, v1PersistentVolumeSpec.vsphereVolume);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessModes, awsElasticBlockStore, azureDisk, azureFile, capacity, cephfs, cinder, claimRef, csi, fc, flexVolume, flocker, gcePersistentDisk, glusterfs, hostPath, iscsi, local, mountOptions, nfs, nodeAffinity, persistentVolumeReclaimPolicy, photonPersistentDisk, portworxVolume, quobyte, rbd, scaleIO, storageClassName, storageos, volumeMode, vsphereVolume);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1PersistentVolumeSpec {\n");
    sb.append("    accessModes: ").append(toIndentedString(accessModes)).append("\n");
    sb.append("    awsElasticBlockStore: ").append(toIndentedString(awsElasticBlockStore)).append("\n");
    sb.append("    azureDisk: ").append(toIndentedString(azureDisk)).append("\n");
    sb.append("    azureFile: ").append(toIndentedString(azureFile)).append("\n");
    sb.append("    capacity: ").append(toIndentedString(capacity)).append("\n");
    sb.append("    cephfs: ").append(toIndentedString(cephfs)).append("\n");
    sb.append("    cinder: ").append(toIndentedString(cinder)).append("\n");
    sb.append("    claimRef: ").append(toIndentedString(claimRef)).append("\n");
    sb.append("    csi: ").append(toIndentedString(csi)).append("\n");
    sb.append("    fc: ").append(toIndentedString(fc)).append("\n");
    sb.append("    flexVolume: ").append(toIndentedString(flexVolume)).append("\n");
    sb.append("    flocker: ").append(toIndentedString(flocker)).append("\n");
    sb.append("    gcePersistentDisk: ").append(toIndentedString(gcePersistentDisk)).append("\n");
    sb.append("    glusterfs: ").append(toIndentedString(glusterfs)).append("\n");
    sb.append("    hostPath: ").append(toIndentedString(hostPath)).append("\n");
    sb.append("    iscsi: ").append(toIndentedString(iscsi)).append("\n");
    sb.append("    local: ").append(toIndentedString(local)).append("\n");
    sb.append("    mountOptions: ").append(toIndentedString(mountOptions)).append("\n");
    sb.append("    nfs: ").append(toIndentedString(nfs)).append("\n");
    sb.append("    nodeAffinity: ").append(toIndentedString(nodeAffinity)).append("\n");
    sb.append("    persistentVolumeReclaimPolicy: ").append(toIndentedString(persistentVolumeReclaimPolicy)).append("\n");
    sb.append("    photonPersistentDisk: ").append(toIndentedString(photonPersistentDisk)).append("\n");
    sb.append("    portworxVolume: ").append(toIndentedString(portworxVolume)).append("\n");
    sb.append("    quobyte: ").append(toIndentedString(quobyte)).append("\n");
    sb.append("    rbd: ").append(toIndentedString(rbd)).append("\n");
    sb.append("    scaleIO: ").append(toIndentedString(scaleIO)).append("\n");
    sb.append("    storageClassName: ").append(toIndentedString(storageClassName)).append("\n");
    sb.append("    storageos: ").append(toIndentedString(storageos)).append("\n");
    sb.append("    volumeMode: ").append(toIndentedString(volumeMode)).append("\n");
    sb.append("    vsphereVolume: ").append(toIndentedString(vsphereVolume)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

