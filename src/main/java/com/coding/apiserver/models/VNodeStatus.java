/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: release-1.16
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.coding.apiserver.models;

import java.util.Objects;

import com.coding.apiserver.custom.Quantity;
import com.google.gson.annotations.SerializedName;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * NodeStatus is information about the current status of a node.
 */
@ApiModel(description = "NodeStatus is information about the current status of a node.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2020-04-29T07:27:12.312Z[Etc/UTC]")
public class VNodeStatus {
  public static final String SERIALIZED_NAME_ADDRESSES = "addresses";
  @SerializedName(SERIALIZED_NAME_ADDRESSES)
  private List<VNodeAddress> addresses = null;

  public static final String SERIALIZED_NAME_ALLOCATABLE = "allocatable";
  @SerializedName(SERIALIZED_NAME_ALLOCATABLE)
  private Map<String, Quantity> allocatable = null;

  public static final String SERIALIZED_NAME_CAPACITY = "capacity";
  @SerializedName(SERIALIZED_NAME_CAPACITY)
  private Map<String, Quantity> capacity = null;

  public static final String SERIALIZED_NAME_CONDITIONS = "conditions";
  @SerializedName(SERIALIZED_NAME_CONDITIONS)
  private List<VNodeCondition> conditions = null;

  public static final String SERIALIZED_NAME_CONFIG = "config";
  @SerializedName(SERIALIZED_NAME_CONFIG)
  private VNodeConfigStatus config;

  public static final String SERIALIZED_NAME_DAEMON_ENDPOINTS = "daemonEndpoints";
  @SerializedName(SERIALIZED_NAME_DAEMON_ENDPOINTS)
  private VNodeDaemonEndpoints daemonEndpoints;

  public static final String SERIALIZED_NAME_IMAGES = "images";
  @SerializedName(SERIALIZED_NAME_IMAGES)
  private List<VContainerImage> images = null;

  public static final String SERIALIZED_NAME_NODE_INFO = "nodeInfo";
  @SerializedName(SERIALIZED_NAME_NODE_INFO)
  private VNodeSystemInfo nodeInfo;

  public static final String SERIALIZED_NAME_PHASE = "phase";
  @SerializedName(SERIALIZED_NAME_PHASE)
  private String phase;

  public static final String SERIALIZED_NAME_VOLUMES_ATTACHED = "volumesAttached";
  @SerializedName(SERIALIZED_NAME_VOLUMES_ATTACHED)
  private List<VAttachedVolume> volumesAttached = null;

  public static final String SERIALIZED_NAME_VOLUMES_IN_USE = "volumesInUse";
  @SerializedName(SERIALIZED_NAME_VOLUMES_IN_USE)
  private List<String> volumesInUse = null;


  public VNodeStatus addresses(List<VNodeAddress> addresses) {

    this.addresses = addresses;
    return this;
  }

  public VNodeStatus addAddressesItem(VNodeAddress addressesItem) {
    if (this.addresses == null) {
      this.addresses = new ArrayList<VNodeAddress>();
    }
    this.addresses.add(addressesItem);
    return this;
  }

   /**
   * List of addresses reachable to the node. Queried from cloud provider, if available. More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses Note: This field is declared as mergeable, but the merge key is not sufficiently unique, which can cause data corruption when it is merged. Callers should instead use a full-replacement patch. See http://pr.k8s.io/79391 for an example.
   * @return addresses
  **/

  @ApiModelProperty(value = "List of addresses reachable to the node. Queried from cloud provider, if available. More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses Note: This field is declared as mergeable, but the merge key is not sufficiently unique, which can cause data corruption when it is merged. Callers should instead use a full-replacement patch. See http://pr.k8s.io/79391 for an example.")

  public List<VNodeAddress> getAddresses() {
    return addresses;
  }


  public void setAddresses(List<VNodeAddress> addresses) {
    this.addresses = addresses;
  }


  public VNodeStatus allocatable(Map<String, Quantity> allocatable) {

    this.allocatable = allocatable;
    return this;
  }

  public VNodeStatus putAllocatableItem(String key, Quantity allocatableItem) {
    if (this.allocatable == null) {
      this.allocatable = new HashMap<String, Quantity>();
    }
    this.allocatable.put(key, allocatableItem);
    return this;
  }

   /**
   * Allocatable represents the resources of a node that are available for scheduling. Defaults to Capacity.
   * @return allocatable
  **/

  @ApiModelProperty(value = "Allocatable represents the resources of a node that are available for scheduling. Defaults to Capacity.")

  public Map<String, Quantity> getAllocatable() {
    return allocatable;
  }


  public void setAllocatable(Map<String, Quantity> allocatable) {
    this.allocatable = allocatable;
  }


  public VNodeStatus capacity(Map<String, Quantity> capacity) {

    this.capacity = capacity;
    return this;
  }

  public VNodeStatus putCapacityItem(String key, Quantity capacityItem) {
    if (this.capacity == null) {
      this.capacity = new HashMap<String, Quantity>();
    }
    this.capacity.put(key, capacityItem);
    return this;
  }

   /**
   * Capacity represents the total resources of a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
   * @return capacity
  **/

  @ApiModelProperty(value = "Capacity represents the total resources of a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity")

  public Map<String, Quantity> getCapacity() {
    return capacity;
  }


  public void setCapacity(Map<String, Quantity> capacity) {
    this.capacity = capacity;
  }


  public VNodeStatus conditions(List<VNodeCondition> conditions) {

    this.conditions = conditions;
    return this;
  }

  public VNodeStatus addConditionsItem(VNodeCondition conditionsItem) {
    if (this.conditions == null) {
      this.conditions = new ArrayList<VNodeCondition>();
    }
    this.conditions.add(conditionsItem);
    return this;
  }

   /**
   * Conditions is an array of current observed node conditions. More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
   * @return conditions
  **/

  @ApiModelProperty(value = "Conditions is an array of current observed node conditions. More info: https://kubernetes.io/docs/concepts/nodes/node/#condition")

  public List<VNodeCondition> getConditions() {
    return conditions;
  }


  public void setConditions(List<VNodeCondition> conditions) {
    this.conditions = conditions;
  }


  public VNodeStatus config(VNodeConfigStatus config) {

    this.config = config;
    return this;
  }

   /**
   * Get config
   * @return config
  **/

  @ApiModelProperty(value = "")

  public VNodeConfigStatus getConfig() {
    return config;
  }


  public void setConfig(VNodeConfigStatus config) {
    this.config = config;
  }


  public VNodeStatus daemonEndpoints(VNodeDaemonEndpoints daemonEndpoints) {

    this.daemonEndpoints = daemonEndpoints;
    return this;
  }

   /**
   * Get daemonEndpoints
   * @return daemonEndpoints
  **/

  @ApiModelProperty(value = "")

  public VNodeDaemonEndpoints getDaemonEndpoints() {
    return daemonEndpoints;
  }


  public void setDaemonEndpoints(VNodeDaemonEndpoints daemonEndpoints) {
    this.daemonEndpoints = daemonEndpoints;
  }


  public VNodeStatus images(List<VContainerImage> images) {

    this.images = images;
    return this;
  }

  public VNodeStatus addImagesItem(VContainerImage imagesItem) {
    if (this.images == null) {
      this.images = new ArrayList<VContainerImage>();
    }
    this.images.add(imagesItem);
    return this;
  }

   /**
   * List of container images on this node
   * @return images
  **/

  @ApiModelProperty(value = "List of container images on this node")

  public List<VContainerImage> getImages() {
    return images;
  }


  public void setImages(List<VContainerImage> images) {
    this.images = images;
  }


  public VNodeStatus nodeInfo(VNodeSystemInfo nodeInfo) {

    this.nodeInfo = nodeInfo;
    return this;
  }

   /**
   * Get nodeInfo
   * @return nodeInfo
  **/

  @ApiModelProperty(value = "")

  public VNodeSystemInfo getNodeInfo() {
    return nodeInfo;
  }


  public void setNodeInfo(VNodeSystemInfo nodeInfo) {
    this.nodeInfo = nodeInfo;
  }


  public VNodeStatus phase(String phase) {

    this.phase = phase;
    return this;
  }

   /**
   * NodePhase is the recently observed lifecycle phase of the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never populated, and now is deprecated.
   * @return phase
  **/

  @ApiModelProperty(value = "NodePhase is the recently observed lifecycle phase of the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#phase The field is never populated, and now is deprecated.")

  public String getPhase() {
    return phase;
  }


  public void setPhase(String phase) {
    this.phase = phase;
  }


  public VNodeStatus volumesAttached(List<VAttachedVolume> volumesAttached) {

    this.volumesAttached = volumesAttached;
    return this;
  }

  public VNodeStatus addVolumesAttachedItem(VAttachedVolume volumesAttachedItem) {
    if (this.volumesAttached == null) {
      this.volumesAttached = new ArrayList<VAttachedVolume>();
    }
    this.volumesAttached.add(volumesAttachedItem);
    return this;
  }

   /**
   * List of volumes that are attached to the node.
   * @return volumesAttached
  **/

  @ApiModelProperty(value = "List of volumes that are attached to the node.")

  public List<VAttachedVolume> getVolumesAttached() {
    return volumesAttached;
  }


  public void setVolumesAttached(List<VAttachedVolume> volumesAttached) {
    this.volumesAttached = volumesAttached;
  }


  public VNodeStatus volumesInUse(List<String> volumesInUse) {

    this.volumesInUse = volumesInUse;
    return this;
  }

  public VNodeStatus addVolumesInUseItem(String volumesInUseItem) {
    if (this.volumesInUse == null) {
      this.volumesInUse = new ArrayList<String>();
    }
    this.volumesInUse.add(volumesInUseItem);
    return this;
  }

   /**
   * List of attachable volumes in use (mounted) by the node.
   * @return volumesInUse
  **/

  @ApiModelProperty(value = "List of attachable volumes in use (mounted) by the node.")

  public List<String> getVolumesInUse() {
    return volumesInUse;
  }


  public void setVolumesInUse(List<String> volumesInUse) {
    this.volumesInUse = volumesInUse;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VNodeStatus v1NodeStatus = (VNodeStatus) o;
    return Objects.equals(this.addresses, v1NodeStatus.addresses) &&
        Objects.equals(this.allocatable, v1NodeStatus.allocatable) &&
        Objects.equals(this.capacity, v1NodeStatus.capacity) &&
        Objects.equals(this.conditions, v1NodeStatus.conditions) &&
        Objects.equals(this.config, v1NodeStatus.config) &&
        Objects.equals(this.daemonEndpoints, v1NodeStatus.daemonEndpoints) &&
        Objects.equals(this.images, v1NodeStatus.images) &&
        Objects.equals(this.nodeInfo, v1NodeStatus.nodeInfo) &&
        Objects.equals(this.phase, v1NodeStatus.phase) &&
        Objects.equals(this.volumesAttached, v1NodeStatus.volumesAttached) &&
        Objects.equals(this.volumesInUse, v1NodeStatus.volumesInUse);
  }

  @Override
  public int hashCode() {
    return Objects.hash(addresses, allocatable, capacity, conditions, config, daemonEndpoints, images, nodeInfo, phase, volumesAttached, volumesInUse);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1NodeStatus {\n");
    sb.append("    addresses: ").append(toIndentedString(addresses)).append("\n");
    sb.append("    allocatable: ").append(toIndentedString(allocatable)).append("\n");
    sb.append("    capacity: ").append(toIndentedString(capacity)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    config: ").append(toIndentedString(config)).append("\n");
    sb.append("    daemonEndpoints: ").append(toIndentedString(daemonEndpoints)).append("\n");
    sb.append("    images: ").append(toIndentedString(images)).append("\n");
    sb.append("    nodeInfo: ").append(toIndentedString(nodeInfo)).append("\n");
    sb.append("    phase: ").append(toIndentedString(phase)).append("\n");
    sb.append("    volumesAttached: ").append(toIndentedString(volumesAttached)).append("\n");
    sb.append("    volumesInUse: ").append(toIndentedString(volumesInUse)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

